# 设计目标与未来计划 (Design Goals & Roadmap)

本文档记录了游戏未来计划实现的核心功能和设计思路。

## 1. CPU核心能力进阶系统

这是游戏的核心成长机制，玩家将通过故事解锁CPU的底层计算能力。该系统的核心思想是围绕**数据类型和计算精度**进行升级。

### 1.1. 状态管理 (`character.json`)

- 需要在 `character.json` 中添加一个名为 `cpu_features` 的数组（list）。
- 此数组用于存放主角已解锁的CPU核心特性。这些特性以支持的数据类型和精度来定义，例如：
  ```json
  "cpu_features": ["int16", "int32", "fp16"] 
  ```
- 基础的CPU可能只支持 `int16`，随着游戏进程，玩家可以解锁 `int32`, `int64` (整数) 和 `fp16`, `fp32`, `fp64` (浮点数)。

### 1.2. 玩家反馈 (`cpuinfo` 指令)

- `cpuinfo` 指令的功能将变更为：读取并显示 `cpu_features` 列表，让玩家清楚地看到当前CPU支持的数据类型和精度。
- 这是玩家查看自身成长和能力的主要途径。

### 1.3. 解锁机制 (`actions.json`)

- 需要在 `actions.json` 中新增一种动作类型：`unlock_feature`。
- 该动作的 `payload` 会指定要解锁的特性名称 (例如 `int64` 或 `fp32`)。
- 在故事的关键节点（如安装硬件、从BBS下载驱动），通过剧情选项触发此动作，将新特性添加到 `character.json` 的 `cpu_features` 列表中。

### 1.4. 游戏性体现 (谜题与门槛)

- 这是让整个系统变得有意义的关键。谜题将围绕数据精度和溢出展开。
- **示例1：读取加密密钥** 
  - 一个程序或文件中的密钥是一个64位整数。
  - 如果玩家的CPU仅支持 `int32`，尝试读取该密钥会导致**整数溢出**，得到一个错误的值。
  - 玩家必须通过其他方式升级CPU，在 `cpu_features` 中解锁 `int64` 后，才能正确读取密钥，用于后续的解密或认证。
- **示例2：高精度计算**
  - 一个科学计算或图形渲染任务，需要至少 `fp32` (单精度浮点) 的支持。
  - 如果玩家只解锁了 `fp16` (半精度)，执行相关程序会提示“精度不足，计算结果发散”并失败。
  - 某些终极谜题甚至可能要求 `fp64` (双精度) 才能获得完美解。

---

## 2. 终极目标：CPU微架构与调度模拟

这是一个更长远、更硬核的设计目标，旨在模拟CPU的实际工作方式，创造出独特的“代码优化”或“CPU调试”解谜玩法。

### 2.1. CPU微架构定义 (`character.json`)

- 在 `character.json` 中，用一个 `cpu_arch` 对象来详细定义CPU的微观架构。
- 该对象将包含CPU拥有的**执行单元 (Execution Units)** 及其数量。例如：
  ```json
  "cpu_arch": {
    "execution_units": {
      "integer_alu": 1, 
      "fpu": 0,
      "memory_unit": 1
    }
  }
  ```
- 玩家在游戏中可以升级CPU，增加执行单元的数量或添加新的单元（如FPU）。

### 2.2. 指令成本数据库 (`instructions.json`)

- 创建一个 `instructions.json` 文件，作为指令的数据库。
- 为每条指令（如`ADD_INT`, `MUL_FP`, `LOAD_MEM`）定义其属性：
  - **执行成本**: 需要多少“时钟周期”或“微指令(μops)”才能完成。
  - **所需单元**: 需要哪种类型的执行单元。

### 2.3. “代码优化”解谜玩法

- 当玩家需要“运行”或“调试”一段模拟的汇编代码时，游戏进入此模式。
- **目标**: 以最少的“时钟周期”（回合）执行完给定的所有指令。
- **玩法**: 玩家在每个周期中，将指令列表中的指令分配到 `cpu_arch` 中可用的执行单元上。
- **挑战**: 玩家需要像一个真正的编译器或CPU乱序执行引擎一样，考虑**资源冲突**（多个指令抢一个单元）、**数据依赖**（指令的先后顺序）和**指令成本**（高成本指令会长时间占用单元），来找出最优的调度方案。

---

## 3. 混合媒体叙事：本地网页展示系统

这是一个用于解决纯文本终端无法展示图片、复杂排版等视觉信息的中期计划。

### 3.1. 核心思想

- **单向信息展示**: 此系统的主要目的是**展示**，而非**互动**。
- **调用真实浏览器**: 游戏通过调用玩家电脑上的默认浏览器来显示内容。
- **本地静态文件**: 浏览器加载的是预先制作好的、存储在项目本地 `sites/` 目录下的静态HTML文件（包含CSS和图片）。

### 3.2. 玩家体验流程

1. 玩家在游戏终端中输入 `browse <网址>` 指令。
2. 游戏引擎在 `websites.json` 中找到对应条目，并获取其本地HTML文件名。
3. 引擎使用 `webbrowser` 模块，打开一个指向本地HTML文件的URL (e.g., `file:///path/to/project/sites/some_site.html`)。
4. 玩家的默认浏览器启动，并显示该网页。
5. 玩家从网页上获取信息（如图片、地图、密码线索），然后手动关闭浏览器或切回游戏终端窗口，利用新获得的信息继续游戏。

### 3.3. 实现要点

- **无需本地服务器**: 此方案避免了在游戏中内嵌HTTP服务器的复杂性。
- **无需双向通信**: 网页是静态的，不包含任何能将信息传回游戏引擎的脚本或链接。
- **内容驱动**: 需要为每个“网站”创建对应的HTML和CSS文件，以及所需的图片资源。
