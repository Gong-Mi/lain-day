#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <sys/stat.h>
#include <stdbool.h>
#include <libgen.h> // For dirname
#include <errno.h> // Required for errno and strerror

#include "build_info.h"
#include "game_types.h"
#include "data_loader.h"
#include "map_loader.h"
#include "story_parser.h"
#include "executor.h"
#include "string_table.h"
#include "scenes.h"
#include "ansi_colors.h"
#include "project_status.h"
#include "flag_system.h"
#include "compression_util.h"
#include <zlib.h>
#include <pthread.h>
#include <termios.h>
#include <unistd.h>
#include "time_utils.h" // Include new shared time utilities
#include "characters/mika.h"
#include "linenoise.h" // Use linenoise for input handling

// This header is auto-generated by CMake and contains the hardcoded character.json data
#include "character_data.h"

// --- Function Prototypes ---

#include "render_utils.h"

// System Helpers

// Path Management
void get_base_path(char* exe_path, char* base_path, size_t size);
void init_paths(char* argv0, GamePaths* paths);

// Game Loop Components
int copy_file(const char *src_path, const char *dest_path);
void render_current_scene(const StoryScene* scene, const struct GameState* game_state); // Updated to struct GameState*
void get_next_input(char* buffer, int buffer_size, int argc, char* argv[], int* arg_index);
int is_numeric(const char* str);
int write_string_to_file(const char* str, const char* dest_path); // New function prototype


int main(int argc, char *argv[]) {
    init_mika_module();
    // Raw mode is now handled by linenoise internally when reading input
    pthread_t time_thread_id;
    pthread_mutex_init(&time_mutex, NULL);

    printf("Lain-day C version starting...\n");
    printf("Build Info - OS: %s, Arch: %s\n", BUILD_OS, BUILD_ARCH);


    GamePaths paths;
    init_paths(argv[0], &paths);

    char session_name[MAX_NAME_LENGTH];
    char session_dir_path[MAX_PATH_LENGTH];
    char character_session_file_path[MAX_PATH_LENGTH];
    
    int arg_index = 1;
    bool is_test_mode = false;

    struct GameState game_state; // Use struct GameState as the full type is now available
    memset(&game_state, 0, sizeof(struct GameState)); // Use struct GameState here too
    g_game_state_ptr = &game_state; // Set the global pointer here

    while (arg_index < argc && argv[arg_index][0] == '-') {
        if (strcmp(argv[arg_index], "-d") == 0) {
            is_test_mode = true;
            printf("Running in test mode (-d). Temporary session.\n");
        } else {
            fprintf(stderr, "Warning: Unknown argument '%s'. Ignoring.\n", argv[arg_index]);
        }
        arg_index++;
    }

    // --- Session Management ---
    if (is_test_mode) {
        printf("Test mode enabled. Using default character state without session persistence.\n");
        // In test mode, create a temporary character.json in the current (build) directory.
        char temp_char_path[MAX_PATH_LENGTH];
        snprintf(temp_char_path, MAX_PATH_LENGTH, "test_char.json"); 
        if (!write_string_to_file(CHARACTER_JSON_DATA, temp_char_path)) {
            fprintf(stderr, "Error: Failed to write embedded character data to temp file for test mode.\n");
            return 1;
        }
        strncpy(character_session_file_path, temp_char_path, MAX_PATH_LENGTH - 1);
        } else { // Normal mode - persistent session
            if (argc > arg_index) {
                strncpy(session_name, argv[arg_index], MAX_NAME_LENGTH - 1);
                session_name[MAX_NAME_LENGTH - 1] = '\0';
                printf("Using session name from argument: %s\n", session_name);
                arg_index++;
            } else {
                bool name_valid = false;
                while(!name_valid) {
                    char* line = linenoise("请输入会话名称 (例如 'new_game' 或 'resume_game'): ");
                    if (line != NULL) {
                        strncpy(session_name, line, MAX_NAME_LENGTH - 1);
                        session_name[MAX_NAME_LENGTH - 1] = '\0';
                        free(line);

                        if (strlen(session_name) > 0) {
                            name_valid = true;
                        } else {
                            printf("会话名称不能为空，请重新输入。\n");
                        }
                    } else {
                        fprintf(stderr, "Error: Failed to read session name.\n");
                        return 1;
                    }
                }
            }

        // Create session directories
        mkdir(paths.session_root_dir, 0755);
        snprintf(session_dir_path, MAX_PATH_LENGTH, "%s/%s", paths.session_root_dir, session_name);
        mkdir(session_dir_path, 0755);
        
        snprintf(character_session_file_path, MAX_PATH_LENGTH, "%s/character.json", session_dir_path);

        if (access(character_session_file_path, F_OK) == -1) {
            printf("Creating new session '%s' from embedded data.\n", session_name);
            // Instead of copying a file, write the hardcoded JSON data to the new session file.
            if (!write_string_to_file(CHARACTER_JSON_DATA, character_session_file_path)) {
                fprintf(stderr, "Error: Failed to write embedded character data to session file.\n");
                return 1;
            }
        } else {
            printf("Resuming session '%s'.\n", session_name);
        }
    }
        
    // --- Load all game data using paths struct ---
    if (!load_player_state(character_session_file_path, &game_state)) {
        // ... error handling
        return 1;
    }
    printf("Player data loaded.\n");

    // Check for time glitch immediately after loading
    const char* glitch_flag = hash_table_get(game_state.flags, "TIME_GLITCH_ACTIVE");
    if (glitch_flag != NULL && strcmp(glitch_flag, "1") == 0) {
        strncpy(game_state.current_story_file, "SCENE_TIME_GLITCH", MAX_PATH_LENGTH - 1);
        #ifdef USE_DEBUG_LOGGING
            fprintf(stderr, "DEBUG: TIME_GLITCH_ACTIVE is set. Forcing transition to SCENE_TIME_GLITCH.\n");
        #endif
    }
#ifdef USE_DEBUG_LOGGING
    fprintf(stderr, "DEBUG: Main: Player location after loading: '%s'\n", game_state.player_state.location);
#endif

    if (!load_map_data(paths.map_dir, (GameState*)&game_state)) { // Cast to GameState*
        // ... error handling
        return 1;
    }
    printf("Map data loaded.\n");

    if (!load_items_data(paths.items_file, (GameState*)&game_state)) { // Cast to GameState*
        // ... error handling
        return 1;
    }
    printf("Items data loaded.\n");
#ifdef USE_DEBUG_LOGGING
    fprintf(stderr, "DEBUG: main: g_string_table[TEXT_DOWNSTAIRS_DESC1] = %s\n", g_string_table[TEXT_DOWNSTAIRS_DESC1]);
    fprintf(stderr, "DEBUG: main: g_string_table[TEXT_LAIN_ROOM_TITLE] = %s\n", g_string_table[TEXT_LAIN_ROOM_TITLE]);
    fprintf(stderr, "DEBUG: main: get_string_by_id(70) returns: %s\n", get_string_by_id(70));
    fprintf(stderr, "DEBUG: main: get_string_by_id(TEXT_DOWNSTAIRS_DESC1) returns: %s\n", get_string_by_id(TEXT_DOWNSTAIRS_DESC1));
    fprintf(stderr, "DEBUG: main: get_string_by_id(25) returns: %s\n", get_string_by_id(25));
    fprintf(stderr, "DEBUG: main: get_string_by_id(TEXT_LAIN_ROOM_TITLE) returns: %s\n", get_string_by_id(TEXT_LAIN_ROOM_TITLE));
#endif

    pthread_create(&time_thread_id, NULL, time_thread_func, (void*)&game_state); // Cast to void*
    
    // --- Game Loop ---
    char input_buffer[MAX_LINE_LENGTH];
    StoryScene current_scene;

    pthread_mutex_lock(&time_mutex);
    if (!transition_to_scene(game_state.current_story_file, &current_scene, (GameState*)&game_state)) { // Cast to GameState*
        fprintf(stderr, "Failed to initialize starting scene: %s\n", game_state.current_story_file);
        pthread_mutex_unlock(&time_mutex);
        return 1;
    }
    render_current_scene(&current_scene, (GameState*)&game_state); // Cast to GameState*
    pthread_mutex_unlock(&time_mutex);

    while (game_is_running) {
        get_next_input(input_buffer, sizeof(input_buffer), argc, argv, &arg_index);
        
        pthread_mutex_lock(&time_mutex);

        if (strcmp(input_buffer, "quit") == 0 || strcmp(input_buffer, "0") == 0) {
            game_is_running = false;
        } else if (is_numeric(input_buffer)) {
            // ... [choice processing logic] ...
            int target_visible_index = atoi(input_buffer);
            int visible_choice_count = 0;
            int target_array_index = -1;

            for (int i = 0; i < current_scene.choice_count; i++) {
                const StoryChoice* choice = &current_scene.choices[i];
                int is_selectable = 0;
                if (choice->condition.flag_name[0] == '\0') {
                    is_selectable = 1;
                } else {
                    const char* flag_value_str = hash_table_get(game_state.flags, choice->condition.flag_name);
                    if (flag_value_str != NULL) {
                        if (atoi(flag_value_str) == choice->condition.required_value) {
                            is_selectable = 1;
                        }
                    }
                }
                
                if (is_selectable) {
                    visible_choice_count++;
                    if (visible_choice_count == target_visible_index) {
                        target_array_index = i;
                        break;
                    }
                }
            }

            if (target_array_index != -1) {
                const char* action_id = current_scene.choices[target_array_index].action_id;
                
                if (execute_action(action_id, (GameState*)&game_state)) { // Cast to GameState*
                    if (!transition_to_scene(game_state.current_story_file, &current_scene, (GameState*)&game_state)) { // Cast to GameState*
                        fprintf(stderr, "Failed to transition to scene %s.\n", game_state.current_story_file);
                    }
                }
            } else {
                printf("Invalid choice number.\n");
            }
            render_current_scene(&current_scene, (GameState*)&game_state); // Cast to GameState*

        } else {
            // execute_command now returns true if a scene re-render is desired/necessary.
            bool should_re_render = execute_command(input_buffer, (GameState*)&game_state); // Cast to GameState*
            if (should_re_render) {
                // If a re-render is needed, transition to the scene specified in game_state.current_story_file
                if (!transition_to_scene(game_state.current_story_file, &current_scene, (GameState*)&game_state)) {
                    fprintf(stderr, "Failed to transition to scene %s after command execution.\n", game_state.current_story_file);
                    game_is_running = false; // Exit game on critical error
                }
                render_current_scene(&current_scene, (GameState*)&game_state); // Cast to GameState*
            }
        }
        pthread_mutex_unlock(&time_mutex);
    }

    // --- Save and Cleanup ---
    pthread_join(time_thread_id, NULL);

    if (!is_test_mode) {
        printf("\nSaving game state...\n");
        if (!save_game_state(character_session_file_path, (GameState*)&game_state)) { // Cast to GameState*
            fprintf(stderr, "Error: Failed to save game state to %s.\n", character_session_file_path);
        } else {
            printf("Game state saved successfully.\n");
        }
    } else {
        printf("\nTest mode: Skipping game state saving.\n");
    }
    
    cleanup_game_state((GameState*)&game_state); // Cast to GameState*
    pthread_mutex_destroy(&time_mutex);

    printf("\nLain-day C version exiting.\n");
    return 0;
}


// --- Function Definitions ---

void get_base_path(char* exe_path, char* base_path, size_t size) {
    char* exe_dir = dirname(exe_path);
    snprintf(base_path, size, "%s/../..", exe_dir);
}

void init_paths(char* argv0, GamePaths* paths) {
    char exe_path[MAX_PATH_LENGTH];
    char* resolved_path = realpath(argv0, exe_path);
    if (resolved_path == NULL) {
        fprintf(stderr, "Error: Could not resolve executable path for '%s'. %s\n", argv0, strerror(errno));
        exit(EXIT_FAILURE);
    }

    char current_path[MAX_PATH_LENGTH];
    strncpy(current_path, dirname(resolved_path), MAX_PATH_LENGTH - 1);

    // Search upwards for a directory containing a ".git" folder
    for (int i = 0; i < 10; ++i) { // Limit search depth to 10 levels
        char git_path[MAX_PATH_LENGTH];
        snprintf(git_path, sizeof(git_path), "%s/.git", current_path);
        
        struct stat st;
        if (stat(git_path, &st) == 0 && S_ISDIR(st.st_mode)) {
            // Found the root directory
            snprintf(paths->base_path, sizeof(paths->base_path), "%s", current_path);
            snprintf(paths->items_file, sizeof(paths->items_file), "%s/items.json", paths->base_path);
            snprintf(paths->map_dir, sizeof(paths->map_dir), "%s/map", paths->base_path);
            snprintf(paths->session_root_dir, sizeof(paths->session_root_dir), "%s/session", paths->base_path);
            return;
        }

        // Move up one directory
        char temp_path[MAX_PATH_LENGTH];
        snprintf(temp_path, sizeof(temp_path), "%s/..", current_path);
        if (realpath(temp_path, current_path) == NULL) {
            break; // Could not move up further
        }
    }

    fprintf(stderr, "Error: Could not find project root directory (containing .git folder).\n");
    exit(EXIT_FAILURE);
}

int copy_file(const char *src_path, const char *dest_path) {
    FILE *src = fopen(src_path, "rb");
    if (src == NULL) {
        fprintf(stderr, "Error: Could not open source file %s\n", src_path);
        return 0;
    }

    FILE *dest = fopen(dest_path, "wb");
    if (dest == NULL) {
        fprintf(stderr, "Error: Could not open destination file %s\n", dest_path);
        fclose(src);
        return 0;
    }

    char buffer[4096];
    size_t bytes_read;
    while ((bytes_read = fread(buffer, 1, sizeof(buffer), src)) > 0) {
        fwrite(buffer, 1, bytes_read, dest);
    }

    fclose(src);
    fclose(dest);
    return 1;
}

int write_string_to_file(const char* str, const char* dest_path) {
    FILE* dest = fopen(dest_path, "wb");
    if (dest == NULL) {
        fprintf(stderr, "Error: Could not open destination file %s\n", dest_path);
        return 0;
    }
    size_t len = strlen(str);
    if (fwrite(str, 1, len, dest) != len) {
        fprintf(stderr, "Error: Failed to write entire string to %s\n", dest_path);
        fclose(dest);
        return 0;
    }
    fclose(dest);
    return 1;
}

void render_current_scene(const StoryScene* scene, const struct GameState* game_state) {
    #ifdef USE_CLEAR_SCREEN
    clear_screen(); // Clear screen for each scene render
    #endif
    print_game_time(game_state->time_of_day); // Print time at the top-left
    #ifdef USE_DEBUG_LOGGING
    fprintf(stderr, "DEBUG: Entering render_current_scene.\n");
    fprintf(stderr, "DEBUG: render_current_scene: scene ptr: %p\n", (void*)scene);
    fprintf(stderr, "DEBUG: Rendering scene: %s (ID: %s)\n", scene->name, scene->scene_id);
    #endif
    if (scene == NULL) {
        printf("Error: Scene is NULL.\n");
        return;
    }

    printf("\n========================================\n");
    if (scene->location_id[0] != '\0') {
        // This part doesn't need typewriter effect
        printf("Location: %s\n", scene->location_id);
    }
    printf("========================================\n");

    for (int i = 0; i < scene->dialogue_line_count; i++) {
    #ifdef USE_STRING_DEBUG_LOGGING
        fprintf(stderr, "DEBUG:   Printing DialogueLine: speaker=%d, text_id=%d (%s)\n",
                scene->dialogue_lines[i].speaker_id, scene->dialogue_lines[i].text_id,
                get_string_by_id(scene->dialogue_lines[i].text_id));
    #endif
        print_colored_line(scene->dialogue_lines[i].speaker_id, scene->dialogue_lines[i].text_id, (GameState*)game_state); // Cast to GameState*
    }

    // --- Check for character presence ---
    const CharacterMika* mika = get_mika_module();
    // Don't print this if the current scene is about Mika's room, as it would be redundant.
    if (strcmp(mika->current_location_id, game_state->player_state.location) == 0 &&
        strcmp(scene->scene_id, "SCENE_MIKA_ROOM_UNLOCKED") != 0) 
    {
        printf(ANSI_COLOR_YELLOW "\n你看到姐姐美香也在这里。\n" ANSI_COLOR_RESET);
    }
    // --- End check for character presence ---

    if (scene->choice_count > 0) {
        printf("\n--- Choices ---\n");
        int visible_choice_index = 1;
        for (int i = 0; i < scene->choice_count; i++) {
            const StoryChoice* choice = &scene->choices[i];
            int is_selectable = 0;

            // Check if there is a condition
            if (choice->condition.flag_name[0] == '\0') {
                is_selectable = 1; // No condition, always selectable
            } else {
                const char* flag_value_str = hash_table_get(game_state->flags, choice->condition.flag_name);
                if (flag_value_str != NULL) {
                    // Flag exists, compare its value
                    int current_value = atoi(flag_value_str);
                    if (current_value == choice->condition.required_value) {
                        is_selectable = 1;
                    }
                }
                // If flag is not set, is_selectable remains 0.
            }

            if (is_selectable) {
                printf("%d. %s\n", visible_choice_index++, get_string_by_id(choice->text_id));
            } else {
                // Print disabled choice in gray and without a number
                printf("   %s%s%s\n", ANSI_COLOR_BRIGHT_BLACK, get_string_by_id(choice->text_id), ANSI_COLOR_RESET);
            }
        }
        printf("---------------\n");
    }
}

void get_next_input(char* buffer, int buffer_size, int argc, char* argv[], int* arg_index) {
    if (argc > 1 && *arg_index < argc) {
        // Automated mode: get input from command-line arguments
        memset(buffer, 0, buffer_size);
        char* current_arg = argv[*arg_index];

        // Check if the argument starts with a quote
        if (current_arg[0] == '"') {
            // It's a quoted string, potentially spanning multiple arguments
            char temp_buffer[buffer_size];
            memset(temp_buffer, 0, sizeof(temp_buffer));
            
            // Copy the first part (starting with ")
            strncat(temp_buffer, current_arg + 1, sizeof(temp_buffer) - strlen(temp_buffer) - 1);

            // If the argument also ends with a quote, we are done with this part
            if (current_arg[strlen(current_arg) - 1] == '"') {
                temp_buffer[strlen(temp_buffer) - 1] = '\0'; // Remove the trailing quote
            } else {
                // It spans multiple arguments, search for the end
                (*arg_index)++;
                while (*arg_index < argc) {
                    strncat(temp_buffer, " ", sizeof(temp_buffer) - strlen(temp_buffer) - 1);
                    current_arg = argv[*arg_index];
                    strncat(temp_buffer, current_arg, sizeof(temp_buffer) - strlen(temp_buffer) - 1);
                    
                    if (current_arg[strlen(current_arg) - 1] == '"') {
                        temp_buffer[strlen(temp_buffer) - 1] = '\0'; // Remove trailing quote
                        break;
                    }
                    (*arg_index)++;
                }
            }
            strncpy(buffer, temp_buffer, buffer_size - 1);

        } else {
            // It's a normal, unquoted argument
            strncpy(buffer, current_arg, buffer_size - 1);
        }

        buffer[buffer_size - 1] = '\0';
        printf("> %s\n", buffer); // Echo the automated input
        (*arg_index)++;
    } else {
        // Manual mode: get input from stdin using linenoise
        char *line = linenoise("> ");
        if (line != NULL) {
            strncpy(buffer, line, buffer_size - 1);
            buffer[buffer_size - 1] = '\0';
            free(line);
        } else {
            // Handle EOF (Ctrl+D) or other errors
            strncpy(buffer, "quit", buffer_size - 1);
            buffer[buffer_size - 1] = '\0';
        }
    }
}

int is_numeric(const char* str) {
    if (str == NULL || *str == '\0') {
        return 0;
    }
    for (int i = 0; str[i] != '\0'; i++) {
        if (!isdigit((unsigned char)str[i])) {
            return 0;
        }
    }
    return 1;
}
