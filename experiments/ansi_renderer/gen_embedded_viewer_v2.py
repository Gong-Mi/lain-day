import sys
from PIL import Image
import os

def generate_c_viewer(image_path, output_c_path, target_width=250):
    try:
        img = Image.open(image_path).convert("RGB")
    except Exception as e:
        print(f"Error opening image: {e}")
        sys.exit(1)

    # Resize logic
    w, h = img.size
    ratio = h / w
    new_w = target_width
    new_h = int(new_w * ratio)
    
    img = img.resize((new_w, new_h), Image.Resampling.LANCZOS)
    data = list(img.getdata())

    # Generate C Array
    c_array_str = "    "
    for i, pixel in enumerate(data):
        c_array_str += f"0x{pixel[0]:02X},0x{pixel[1]:02X},0x{pixel[2]:02X},"
        if (i + 1) % 16 == 0:
            c_array_str += "\n    "
    
    # We must escape the backslashes for the C strings in this python string
    c_source = f"/**
 * lain_view.c
 * Standalone Embedded Image Viewer for Lain-Day
 * Generated by gen_embedded_viewer.py
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <termios.h>

// --- Definitions ---
#define MOUSE_ENABLE  "\x1b[?1000h\x1b[?1006h"
#define MOUSE_DISABLE "\x1b[?1000l\x1b[?1006l"
#define HIDE_CURSOR   "\x1b[?25l"
#define SHOW_CURSOR   "\x1b[?25h"

// --- Embedded Image Data ---
#define IMG_W {new_w}
#define IMG_H {new_h}

static const uint8_t IMG_DATA[] = {{
{c_array_str}
}};

// --- Globals ---
struct termios g_orig_termios;
volatile int g_need_resize = 1;
int g_term_w = 0;
int g_term_h = 0;

// --- Terminal Control ---

void disable_raw_mode() {{
    printf(MOUSE_DISABLE);
    printf(SHOW_CURSOR);
    printf("\x1b[0m\n"); // Reset colors
    tcsetattr(STDIN_FILENO, TCSAFLUSH, &g_orig_termios);
}}

void enable_raw_mode() {{
    tcgetattr(STDIN_FILENO, &g_orig_termios);
    atexit(disable_raw_mode);

    struct termios raw = g_orig_termios;
    raw.c_lflag &= ~(ECHO | ICANON | ISIG);
    raw.c_cc[VMIN] = 0;
    raw.c_cc[VTIME] = 1;

    tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw);
    printf(MOUSE_ENABLE);
    printf(HIDE_CURSOR);
    fflush(stdout);
}}

void update_terminal_size() {{
    struct winsize ws;
    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1 || ws.ws_col == 0) {{
        g_term_w = 80;
        g_term_h = 24;
    }} else {{
        g_term_w = ws.ws_col;
        g_term_h = ws.ws_row;
    }}
}}

void sigwinch_handler(int sig) {{
    (void)sig;
    g_need_resize = 1;
}}

// --- Render Logic ---

void render() {{
    if (g_term_w <= 0 || g_term_h <= 0) return;

    size_t buf_cap = g_term_w * g_term_h * 24 + 4096;
    char *out_buf = malloc(buf_cap);
    if (!out_buf) return;
    
    char *ptr = out_buf;
    
    // Clear screen and go home
    ptr += sprintf(ptr, "\x1b[2J\x1b[H");

    int term_px_w = g_term_w / 2; 
    int term_px_h = g_term_h;

    float scale_x = (float)IMG_W / term_px_w;
    float scale_y = (float)IMG_H / term_px_h;
    float scale = (scale_x > scale_y) ? scale_x : scale_y;

    // Center the image
    int draw_w = (int)(IMG_W / scale);
    int draw_h = (int)(IMG_H / scale);
    
    if (draw_w > term_px_w) draw_w = term_px_w; // clamp
    if (draw_h > term_px_h) draw_h = term_px_h; // clamp

    int offset_x = (term_px_w - draw_w) / 2;
    int offset_y = (term_px_h - draw_h) / 2;

    int current_r = -1, current_g = -1, current_b = -1;

    for (int y = 0; y < g_term_h; y++) {{
        for (int x = 0; x < term_px_w; x++) {{
            if (y >= offset_y && y < offset_y + draw_h && 
                x >= offset_x && x < offset_x + draw_w) {{

                int img_x = (int)((x - offset_x) * scale);
                int img_y = (int)((y - offset_y) * scale);

                if (img_x < 0) img_x = 0;
                if (img_x >= IMG_W) img_x = IMG_W - 1;
                if (img_y < 0) img_y = 0;
                if (img_y >= IMG_H) img_y = IMG_H - 1;

                const uint8_t *p = &IMG_DATA[(img_y * IMG_W + img_x) * 3];
                uint8_t r = p[0], g = p[1], b = p[2];

                if (r != current_r || g != current_g || b != current_b) {{
                    ptr += sprintf(ptr, "\x1b[48;2;%d;%d;%dm", r, g, b);
                    current_r = r; current_g = g; current_b = b;
                }}
                *ptr++ = ' '; *ptr++ = ' ';

            }} else {{
                if (current_r != -1) {{
                    ptr += sprintf(ptr, "\x1b[0m");
                    current_r = -1; current_g = -1; current_b = -1;
                }}
                *ptr++ = ' '; *ptr++ = ' ';
            }}
        }}
        ptr += sprintf(ptr, "\x1b[0m\n");
        current_r = -1; current_g = -1; current_b = -1;
    }}
    
    // Status Bar
    ptr += sprintf(ptr, "\x1b[7m [Lain-View] %dx%d (Embedded) | Scale: %.2f | Q to Quit \x1b[0m", 
                   IMG_W, IMG_H, scale);

    write(STDOUT_FILENO, out_buf, ptr - out_buf);
    free(out_buf);
}}

int main() {{
    enable_raw_mode();
    signal(SIGWINCH, sigwinch_handler);
    update_terminal_size();
    render();

    char ibuf[64];
    while (1) {{
        if (g_need_resize) {{
            g_need_resize = 0;
            update_terminal_size();
            render();
        }}

        int n = read(STDIN_FILENO, ibuf, sizeof(ibuf) - 1);
        if (n > 0) {{
            ibuf[n] = '\0';
            if (ibuf[0] == 'q' || ibuf[0] == 'Q' || ibuf[0] == 3) break;

            if (ibuf[0] == '\x1b' && ibuf[1] == '[' && ibuf[2] == '<') {{
                int btn, tx, ty;
                char type;
                if (sscanf(ibuf + 3, "%d;%d;%d%c", &btn, &tx, &ty, &type) == 4) {{
                    if (type == 'M') {{
                        char msg[64];
                        int len = snprintf(msg, sizeof(msg), "\033[1;1H\033[41m CLICK: %d,%d \033[0m", tx, ty);
                        write(STDOUT_FILENO, msg, len);
                    }}
                }}
            }}
        }}
        usleep(10000);
    }}
    return 0;
}}
"

    with open(output_c_path, 'w') as f:
        f.write(c_source)
    
    print(f"Generated {output_c_path}")

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print("Usage: python gen.py <img_path> <out_c_path>")
        sys.exit(1)
    
    generate_c_viewer(sys.argv[1], sys.argv[2])
