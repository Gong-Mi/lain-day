# Linenoise (Fork)


This directory contains a fork of the **Linenoise** library, a minimal, zero-config, BSD-licensed replacement for readline. It is designed to be small (less than 20k lines of code) and easy to embed in applications.

This specific version (located in `external/linenoise`) appears to be a vendored dependency for the `lain-day` project.

## Key Features

*   **Minimalistic:** Designed to be lightweight and easy to integrate.
*   **Cross-Platform:** Supports Linux/Unix and Win32 console.
*   **UTF-8 Support:** Full UTF-8 support (can be toggled).
*   **History:** Supports command history (add, save, load).
*   **Completion:** Supports tab completion with callbacks.
*   **Hints:** Supports hints (like autosuggestions).
*   **Multiline:** Supports multiline editing.
*   **Mouse Support:** (New) Supports SGR mouse protocol for touch/click interaction.

## Project Structure

*   **`linenoise.c` / `linenoise.h`**: The core source and header files.
*   **`utf8.c` / `utf8.h`**: implementation of UTF-8 handling.
*   **`stringbuf.c` / `stringbuf.h`**: Helper for string buffer management.
*   **`linenoise-win32.c`**: Windows-specific implementation details.
*   **`example.c`**: A sample application demonstrating how to use the library.
*   **`Makefile`**: Build script for the library and examples.
*   **`linenoise-ship.c`**: A generated file that concatenates sources for easier single-file distribution.

## Building and Running

To build the examples, you can use `make`:

```bash
# Build the standard example
make linenoise_example

# Build the example with UTF-8 support
make linenoise_utf8_example

# Clean build artifacts
make clean
```

Running the example:

```bash
./linenoise_example
# or
./linenoise_example --multiline
```

## Integration

To use this library in the main project:

1.  **Include Header:** `#include "linenoise.h"`
2.  **Compilation:** Compile `linenoise.c` (and `utf8.c`, `stringbuf.c` etc. as needed, or use `linenoise-ship.c`) along with your application source.
3.  **Basic Usage:**

```c
char *line;
while((line = linenoise("prompt> ")) != NULL) {
    if (line[0] != '\0') {
        printf("You typed: %s\n", line);
        linenoiseHistoryAdd(line);
        linenoiseHistorySave("history.txt");
    }
    free(line);
}
```

## API Overview

See `linenoise.h` for the full API. Key functions include:

*   `linenoise(const char *prompt)`: Read a line of input.
*   `linenoiseHistoryAdd(const char *line)`: Add a line to history.
*   `linenoiseHistorySave(const char *filename)`: Save history to disk.
*   `linenoiseHistoryLoad(const char *filename)`: Load history from disk.
*   `linenoiseSetCompletionCallback(...)`: Set a custom tab completion handler.
*   `linenoiseSetMultiLine(int enableml)`: Enable or disable multiline editing.

### Mouse Support API

*   `linenoiseSetMouseSupport(int enable)`:
    *   `0`: Disabled (default).
    *   `1`: Enabled (swallows events, does not interrupt input).
    *   `2`: Enabled (interrupts input, causing `linenoise` to return current buffer).
*   `linenoiseGetLastMouse(int *x, int *y, int *button, int *event_type)`: Retrieve details of the last mouse event.
    *   `x`, `y`: 1-based coordinates.
    *   `button`: Mouse button (0=left, etc.).
    *   `event_type`: 'M' (Press) or 'm' (Release).

### Non-blocking / Multiplexing API (Implemented)

To support real-time games where the UI must refresh (e.g., time ticking, animations) while waiting for user input, the following features have been implemented:

*   **Timeout Support**: [DONE] `linenoise()` now supports a configurable timeout via `linenoiseSetTimeout(ms)`. On timeout, it returns `NULL` and sets `errno = EAGAIN`.
*   **State Persistence**: [DONE] Internal state (buffer, cursor position, history index) is now persistent. Calling `linenoise()` after a timeout resumes exactly where the user left off.
*   **External Refresh**: [DONE] Exposed `linenoiseRefresh()` to allow forced redraws from the external game loop.
*   **Async-Safe Return**: [DONE] Distinguished returns: `NULL` with `errno == EAGAIN` for timeout, `NULL` with `errno != EAGAIN` for EOF/Ctrl-C, and `char*` for successful input.

## 故障责任审计 (Failure Audit - 2025-12-28)

**事件描述**：在集成非阻塞 `linenoise` 后，用户触摸屏幕导致程序发生 `Segmentation fault`。

**责任判定：接口契约破坏 (Contract Breach)**

1.  **引擎层责任 (The Engine)**：
    *   **违规调用**：在 `linenoise()` 函数因异常（如点击中断或 Ctrl-C）返回 `NULL` 且 `errno` 非 `EAGAIN` 时，引擎依然强行调用了 `linenoiseGetLastMouse`。
    *   **状态盲目**：引擎没有识别出 `linenoise` 在返回瞬间可能已经清理了内部临时缓冲区，导致了典型的“售后访问（Use-After-Teardown）”崩溃。

2.  **依赖层责任 (The Library/Fork)**：
    *   **防御性缺失**：`linenoiseGetLastMouse` 内部没有对全局状态进行“零生存期”校验。即使输入循环已结束，该函数仍试图访问可能已处于不稳定状态的内部变量。

**最终结论**：这是一次典型的 **“同步逻辑强行异步化”** 带来的后遗症。由于库与引擎之间没有建立严格的“生命周期围栏”，导致了空指针解引用。

**修复状态：已结案 (RESOLVED - 2025-12-28)**
*   **库侧**：已交付非阻塞 API，支持 `EAGAIN` 返回契约及状态持久化。
*   **引擎侧**：已适配 `errno` 校验，建立 `library_is_safe` 生命周期守卫。
*   **验证**：触摸中断不再引发 Segfault，输入状态在重绘后可完美恢复。